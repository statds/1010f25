# First Impression with Data

## R Packages and Data

R is an open-source language, widely used in data science. One of its
greatest strengths is the ecosystem of packages developed by the
community. These packages make it easier to perform tasks such as
importing data, cleaning it, and creating visualizations.

Two sets of packages will be central for us. 
Package **tidyverse** provides
a coherent framework for data wrangling and visualization. The
**gapminder** package offers a dataset on life expectancy, GDP per
capita, and population across countries and years, which will serve as
a running example in our practice.

If packages are not already installed, we can add them to our system
with `install.packages()`. Installation is needed only once, but
packages must be loaded every time we start a new R session. 

```{r}
#| message: FALSE
#| eval: FALSE
#| echo: TRUE

install.packages("tidyverse")
install.packages("gapminder")
```

Once installed, packages are made available in a session by loading
them with `library()`. 

```{r}
#| message: FALSE
#| echo: TRUE

library(tidyverse)
library(gapminder)
```

After loading a dataset, it is good practice to examine its structure.
Functions such as `str()` and `summary()` provide a quick overview of
variable types, sample values, and ranges.  

```{r}
#| echo: TRUE

str(gapminder)
summary(gapminder)
```


## Exploring Data Frames in R

Once data are loaded, the next step is to **explore and understand the
dataset**. A data frame (or tibble, in tidyverse) is the standard
format for rectangular data. R provides many built-in functions to
examine, summarize, and manipulate data frames.

### Structure and dimensions

- `dim(df)` – number of rows and columns  
- `nrow(df)`, `ncol(df)` – number of rows or columns separately  
- `str(df)` – internal structure (types, first few values)  
- `glimpse(df)` (from dplyr) – a cleaner version of `str`  

### Column names and metadata

- `names(df)` or `colnames(df)` – list column names  
- `rownames(df)` – list row names (rarely used in tidy data)  

### First and last rows

- `head(df)` – first six rows  
- `tail(df)` – last six rows  

### Summaries

- `summary(df)` – variable-by-variable summaries  
- `sapply(df, class)` – variable types  
- `sapply(df, function)` – apply any function to each column (e.g.,
  mean, min, max)  

### Accessing columns and rows

- `df$var` – access a column by name  
- `df[ , "var"]` – same as above, but more general  
- `df[1:5, ]` – first five rows  
- `df[ , 1:3]` – first three columns  

### Subsetting and filtering

- `subset(df, condition)` – filter rows by condition  
- With tidyverse: `filter(df, condition)`, `select(df, cols)`  

### Checking contents

- `unique(df$var)` – unique values in a column  
- `table(df$var)` – frequency counts  
- `is.na(df)` – identify missing values  

Together, these functions give a toolkit for becoming familiar with
any new dataset.


## Variable Types

A crucial step in working with data is recognizing the types of
variables. Variable types determine how we visualize, summarize, and
analyze data.

Variables are broadly divided into **numerical** and **categorical**.
Numerical variables can be *continuous*, such as income or life
expectancy, or *discrete*, such as the number of siblings or a
graduation year. Categorical variables can be *nominal*, with no
inherent order (for example, country or gender), or *ordinal*, with an
order that matters (such as education levels or rankings). R also
provides support for **logical** variables, representing true/false
values, and **date** variables, with built-in functions for handling
time information.  

![Variable types](variables.png)

```{r}
#| echo: TRUE

# Example: variable types in gapminder
glimpse(gapminder)
```

Understanding variable types is not just theoretical. The type guides
decisions about visualization, statistical summaries, and models. For
instance, the mean is meaningful for a numerical variable but not for
a nominal one.


## Messy Data

Real-world datasets are rarely clean. Messiness can arise from missing
values, inconsistent formats, poorly named variables, or categories
coded in multiple ways. Dates might appear in different styles, proper
nouns might be inconsistently capitalized, and numeric values might be
stored as text.

Cleaning data involves identifying and fixing these problems. R
provides many tools for this work. Missing values can be detected with
`is.na()` and handled using functions such as `na.omit()`. Variable
names can be adjusted with `rename()`. The `mutate()` function can
change types or create new variables, and joins such as `left_join()`
allow information from multiple tables to be combined.  

```{r}
#| echo: TRUE

# Example: identify missing values in gapminder
sum(is.na(gapminder))
```

The tidyverse philosophy emphasizes keeping data in a “tidy” format,
where each variable is a column, each observation is a row, and each
type of observation forms its own table. Working toward tidy data
makes later analysis and visualization much easier.

## Putting It Together

To see these ideas in practice, consider analyzing life expectancy in
African countries. We might start by filtering the data to include
only Africa, checking for missing values, and confirming variable
types. Once the data are tidy, we can compute summaries and produce
visualizations that reveal patterns over time.  

```{r}
#| echo: TRUE

africa <- gapminder %>% filter(continent == "Africa")
head(africa)
```

This example illustrates the general workflow: install and load
packages, import data, understand variable types, clean messy data,
and prepare the dataset for analysis.
