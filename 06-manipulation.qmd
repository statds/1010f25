# Data Manipulation

```{r}
#| include: FALSE
library(tidyverse)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE)
```

## Introduction

Raw data are rarely ready for direct analysis. We often need to
reshape, filter, or summarize before we can create meaningful plots
or fit statistical models. The `tidyverse` provides a consistent
grammar for these operations, with `dplyr` as its central package.

In this chapter, we will learn the most important data manipulation
verbs. Each verb is a function that takes a data frame (or tibble)
as the first argument, applies some manipulation, and returns a
new data frame.

::: callout-tip
### Backward Compatibility in the Tidyverse

The tidyverse strives to minimize disruption, but **backward compatibility
is not guaranteed**. Breaking changes sometimes occur---especially in major
releases---to improve consistency or fix design issues. Functions are usually
*deprecated with warnings* before removal, giving time to update code.
For long-term stability, pin package versions with tools like `renv` and
always review release notes when upgrading.
:::

## Core `dplyr` Verbs

The six most commonly used verbs are:

- `filter()` — select rows based on conditions  
- `arrange()` — reorder rows  
- `select()` — choose columns  
- `mutate()` — add or modify columns  
- `group_by()` — define groups for analysis  
- `summarise()` — collapse groups into summaries  

All verbs follow the same pattern: the first argument is a data frame,
and subsequent arguments describe manipulations using column names.

We will illustrate these verbs using the `nycflights13::flights`
dataset.

```{r}
library(nycflights13)
flights <- nycflights13::flights
str(flights)
```

### Filtering Rows with `filter()`

The `filter()` function selects rows that satisfy logical conditions.
Logical operators like `&` (and), `|` (or), and `!` (not) are often
used, along with comparisons such as `==`, `!=`, `<`, and `>=`.


- `==` equals
- `!=` not equal
- `<` less than, `<=` less than or equal
- `>` greater than, `>=` greater than or equal
- `&` logical AND (both conditions must be true)
- `|` logical OR (at least one condition must be true)
- `!` logical NOT (negates a condition)


Examples with the `flights` data:
```{r}
# Flights on January 1
flights |>
filter(month == 1 & day == 1)

# Flights in January or February
flights |>
filter(month == 1 | month == 2)

# Flights not in January
flights |>
filter(!(month == 1))

# Flights with arrival delay over 2 hours and from JFK
flights |>
filter(arr_delay > 120 & origin == "JFK")

# Flights that were either very early (dep_delay < -15) or very late (dep_delay > 120)
flights |>
filter(dep_delay < -15 | dep_delay > 120)

# Flights in summer months AND either from JFK or LGA
flights |>
filter((month %in% c(6,7,8)) & (origin == "JFK" | origin == "LGA"))

# Flights in December with departure delay over 2 hours OR (in January with arrival delay over 2 hours)
flights |>
filter((month == 12 & dep_delay > 120) | (month == 1 & arr_delay > 120))

# Flights from EWR where either (dep_delay > 60 AND arr_delay > 60) OR (dep_delay < -30 AND arr_delay < -30)
flights |>
filter(origin == "EWR" & ((dep_delay > 60 & arr_delay > 60) |
(dep_delay < -30 & arr_delay < -30)))
```


#### Handling Missing Values

Missing values (`NA`) require care. For example:

```{r}
stocks <- data.frame(
  year   = c(2015, 2015, 2016, 2016),
  qtr    = c(1, 2, 2, NA),
  return = c(1.1, NA, 0.9, 2.0)
)

stocks |> filter(is.na(qtr) | is.na(return))
stocks |> filter(!is.na(qtr) & !is.na(return))
```

### Reordering Rows with `arrange()`

`arrange()` sorts rows by column values. Missing values are sorted last.

```{r}
flights |> arrange(year, month, day) |> str()
```

Descending order is done with `desc()`:

```{r}
flights |> arrange(desc(dep_delay)) |> str()
```

### Selecting Columns with `select()`

`select()` picks out specific columns. Useful helpers include `starts_with()`
and `ends_with()`.

```{r}
flights |> select(year, month, day) |> str()
flights |> select(starts_with("dep")) |> str()
```

Columns can also be renamed inline:

```{r}
flights |> select(tail = tailnum, everything()) |> str()
```

### Creating New Columns with `mutate()`

`mutate()` adds new variables or modifies existing ones.

```{r}
flights |> mutate(speed = distance / (air_time/60)) |> str()
```

It is common to create multiple new variables at once:

```{r}
flights |> mutate(
  gain = dep_delay - arr_delay,
  hours = air_time / 60
) |> str()
```

### Grouping and Summarizing

The `group_by()` function defines groups of rows, and `summarise()` reduces
each group to summary statistics.

```{r}
flights |>
  group_by(month) |>
  summarise(delay = mean(dep_delay, na.rm = TRUE))
```

Multiple grouping variables are possible:

```{r}
flights |>
  group_by(carrier, month) |>
  summarise(
    delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> str()
```


Sometimes, the keeping the group structured after summarising can be
handy, which can be achieved with `.groups = "keep"`. In this case,
groups persist unless they are explicitly removed with `ungroup()`.
With the default `summarise()`, a single grouping variable is
*dropped*, producing an ungrouped result; so `ungroup()` after that is
redundant.



## Reshaping Data

Real-world data often need reshaping. Tidy data prefers one
observation per row, one variable per column.

### Wide to Long: `pivot_longer()`

```{r}
table4a <- tibble(
  country = c("A", "B"),
  `1999` = c(745, 377),
  `2000` = c(377, 345)
)

table4a |> pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
```

### Long to Wide: `pivot_wider()`

```{r}
table2 <- tibble(
  country = c("A", "A", "B", "B"),
  year = c(1999, 2000, 1999, 2000),
  type = c("cases", "cases", "cases", "cases"),
  count = c(745, 377, 377, 345)
)

table2 |> pivot_wider(names_from = type, values_from = count)
```

## Combining Data from Multiple Tables

Joins combine data from two tables based on a common key column. The type of
join determines which rows are kept:

- Inner Join: Keeps only rows with matching keys in both tables.
- Left Join: Keeps all rows from the left table, adding matches from the
right table where available (missing values filled with `NA`).
- Right Join: Keeps all rows from the right table, adding matches from the
left table where available.
- Full Join: Keeps all rows from both tables, filling unmatched values with
`NA`.




Consider the `planes` data.
```{r}
planes <- nycflights13::planes
str(planes)
```

Join the `flights` data and the `planes` data:
```{r}
flights2 <- flights |> select(year, month, day, carrier, tailnum)
planes2 <- planes |> select(tailnum, type, manufacturer)

flights2 |> left_join(planes2, by = "tailnum") |> str()
# Try inner, right, and full join too
```

Other join types include `inner_join()`, `right_join()`, and `full_join()`.

## Assigning Results of Manipulations

When working with `dplyr`, it is often useful to save the
results of a manipulation into a new object. This allows you
to reuse the processed data without repeating all of the steps.

```{r}
# Filter flights on January 1st and arrange by departure delay
flights_jan1 <- flights |>
filter(month == 1, day == 1) |>
arrange(dep_delay)

# Print the first few rows
head(flights_jan1)
```

You can now work with `flights_jan1` in later code chunks without
re-running the entire manipulation. This practice is especially
helpful for long workflows where the same processed data will be
used multiple times.

## In-Class Example

Consider the data of @chetty2014where. 

1.  Create a data frame with CZs in CT, MA, and NY.
1.  Create a data frame with CZ's with absolute mobility of at least 40
1.  Create a data frame with CZ's in any state other than CT, MA, or
    NY, with absolute mobility at least 40
1.  Create a data frame with CZ's that are in CT, MA, NY and have
    absolute mobility less than 40.
1.  Create a data frame with CZ's that are in CT, MA, NY, sorting the
    CZ's in decreasing order of absolute mobility, and keeping just
    the CZ name, state, and absolute mobility variables in the
    resulting data frames
1. Create a new data set with only the following variables: `cz_name`,
   `state`, `pop_2000`, `abs_mobility`, `hhi_percap`, and any variable
   that starts with `frac`.
1. Make new variables for each of these quantities: 
   a.  The number of people in each CZ who consider themselves to be
   religious. 
   a.  The log base 2 of the per capita household income (hint:
   `log2()` ).
   a.  The proportion of people who are not married. 

## Summary and Best Practices

- Begin with a clear idea of what manipulation you need.  
- Chain verbs together with the pipe operator for readability.  
- Use `group_by()` and `summarise()` to move from raw detail to
  aggregated insights.  
- Reshape and join data as needed to bring it into tidy form.  

These manipulations prepare your data for visualization and modeling,
ensuring clarity and reproducibility in analysis.
