# Geospatial Data

```{r}
#| include: FALSE
library(tidyverse)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE)
```


## Introduction 

- Geographic data corresponds to data that have been linked to a geographic coordinate system

  + Point-referenced: e.g., latitude and longitude
  + Areal: polygons; grid; counties/states
  
- Working with geographically located data is a relatively new phenomenon

  + It requires a significant amount of computing power and specialized programs
  
- Nowadays such lack of geographic data is hard to imagine

  + Every smartphone has a global positioning (GPS) receiver and a multitude of sensors on devices ranging from satellites and semi-autonomous vehicles to citizen scientists incessantly measure every part of the world

  
```{r}
## install.packages("leaflet")
library(leaflet)

popup = c("Storrs, Connecticut")
leaflet() %>% 
  setView(lng = -72.251194, lat = 41.807417, zoom = 1)%>%
  addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") %>%
    addMarkers(lng = c(-72.251194),
             lat = c(41.807417), 
             popup = popup)
```



```{r}
popup = c("SSH Building")
leaflet() %>% 
  setView(lng = -72.251194, lat = 41.807417, zoom = 12)%>%
  addTiles() %>%
  addMarkers(lng = c(-72.251194),
             lat = c(41.807417), 
             popup = popup)
```



There are many ways to handle geographic data in R, with dozens of
packages in the area. The ones that we will focus on in this course
are:

+ `sp`
+ `sf` (very functional with the `tidyverse`)
+ `raster`
  
Honorable mentions:

+ `maptools`
+ `rgdal`
  


## The `sp` Package


The **`sp`** package provides the original infrastructure for handling
spatial data in R. It defines formal S4 classes for representing
geographic features—points, lines, polygons, and grids—together with
their coordinate reference systems (CRS) and attribute data. These
structures form the foundation for spatial analysis, visualization, and
conversion between coordinate systems.  


Although newer packages like **`sf`** now offer simpler data-frame-based
representations, `sp` remains widely used and is essential for
understanding many legacy R spatial workflows.

- The first general package to provide classes and methods for spatial
  data types that was developed for R is called `sp`.
- The package provides classes and methods to create points, lines,
  polygons, and grids and to operate on them.
  

### Building a `sp` Object

Let's build a `sp` object:

```{r}
#install.packages("sp")
library(sp)

#create the highways 
ln1 <- Line(matrix(runif(6), ncol=2))
ln1

ln2 <- Line(matrix(runif(6), ncol=2))
ln2

str(ln1)
```


Note that the `@coords` slot holds the coordinates 


```{r}
## combine the highways to a Lines object
lns1 <- Lines(list(ln1), ID = c("hwy1")) 
lns2 <- Lines(list(ln2), ID = c("hwy2")) 

str(lns1)
```

The `Line` objects are now in a list and we have an additional ID
slot, which uniquely identifies each `Line` object .

```{r}
# create a geospatial object with SpatialLines
sp_lns <- SpatialLines(list(lns1, lns2))

str(sp_lns)
```


A data frame can be created with a column of `SpatialLines`.
```{r}
## create a SpatialLinesDataframe
dfr <- data.frame(id = c("hwy1", "hwy2"), # note how we use the same IDs from above!
                  cars_per_hour = c(78, 22)) 

sp_lns_dfr <- SpatialLinesDataFrame(sp_lns, dfr, match.ID = "id")

str(sp_lns_dfr)

spplot(sp_lns_dfr, "cars_per_hour")
```

### Useful things to know in `sp`

- **Spatial object** — Any data object with geographic coordinates  
  (points, lines, polygons, or grids).

- **CRS (Coordinate Reference System)** — Describes how coordinates
  map to Earth. Example:  
  `CRS("+proj=longlat +datum=WGS84")`.

- `proj4string` — Text form of CRS stored in an `sp` object.

- `@data` — Attribute table (like columns in a data frame).  
  Access with `obj@data`.

- `@coords` — Coordinate matrix of locations.

- `bbox` — Bounding box (spatial extent) of the object.

- `spTransform()` — Converts coordinates to another CRS.

- `over()` — Spatial join (find which polygon a point belongs to).

> **Tip:** The modern package **`sf`** replaces `sp` and uses a simpler
> data frame structure with a `geometry` column.



## The `sf` Package

- `sf` implements a formal standard called “Simple Features” that
  specifies a storage and access model of spatial geometries (point,
  line, polygon). 
- A feature geometry is called simple when it consists of points
  connected by straight line pieces, and does not intersect itself.
  + This standard has been adopted widely.
- Data are structured and conceptualized very differently from the
  `sp` approach.



Let's recreate the `sp` object from above in `sf`

```{r}
## install.packages("sf")
library(sf)

## create the highways 
lnstr_sfg1 <- st_linestring(matrix(runif(6), ncol=2)) 
lnstr_sfg1

lnstr_sfg2 <- st_linestring(matrix(runif(6), ncol=2)) 
lnstr_sfg2

class(lnstr_sfg1)
```

We would then combine this into a simple feature collection.

```{r}
#combine the highways into a simple feature
lnstr_sfc <- st_sfc(lnstr_sfg1, lnstr_sfg2) # just one feature here
lnstr_sfc
```

```{r}
#create our spatial data frame
lnstr_sf <- st_sf(dfr , lnstr_sfc)
lnstr_sf

plot(lnstr_sf["cars_per_hour"])

ggplot(lnstr_sf) + 
  geom_sf(aes(color = cars_per_hour))
```


Useful methods in `sf`:

```{r}
methods(class = "sf")
```


## Raster Data


**Raster data** represent spatial information as a grid of cells (or
pixels), where each cell stores a value for a specific variable such as
elevation, temperature, or land cover. The cells are arranged in rows
and columns, covering a continuous area of space.

Raster data are typically used for continuous phenomena that vary
smoothly across space. The spatial resolution depends on the cell size:
smaller cells capture finer detail but require more storage.

Common raster formats include GeoTIFF and `.grd`. In R, raster data are
handled by packages such as **`raster`** and **`terra`**.


- Raster files, as you might know, have a much more compact data
  structure than vectors.
- A raster is defined by: 
   + a CRS
   + coordinates of its origin
   + a distance or cell size in each direction
   + a dimension or numbers of cells in each direction
   + an array of cell values
  
```{r}
## install.packages("raster")
library(raster)

HARV <- raster("data/HARV_RGB_Ortho.tif")

HARV

plot(HARV)
```

This raster is generated as part of the NEON Harvard Forest field
[site](https://www.neonscience.org/field-sites/harv) .
  

```{r}
## useful commands

crs(HARV)

methods(class = class(HARV))

```



## Maps

- We are going to create a few different types of maps, which will
  require different R packages.

  + Static Maps
  
    + Most common type of visual output 
      
      + `plot()` most commonly used command from base are
      
      + Can utilize `ggplot()` and `tmap()`
      
  + Animated Maps
  
    + Are becoming more widely used than in the past
    
      + We will make these with `tmap()`
      
  + Interactive Maps
  
    + While static and animated maps can enliven geographic datasets, interactive maps can take them to a new level
    
      + `leaflet()`


### Plotting Simple Features (`sf`)

- As we have already briefly seen, the `sf` package extends the base
  plot command, so it can be used on `sf` objects.
- We are going to create a choropleth map with `sf`

```{r}
library(sf)

philly_crimes_sf <- st_read("data/PhillyCrimerate.shp")

glimpse(philly_crimes_sf)

plot(philly_crimes_sf)
```

Notice that the plot function will try and provide a map of every
variable in the data set.


To plot a single attribute, we need to provide an object of class `sf`.

```{r}
plot(philly_crimes_sf$homic_rate) # this is a numeric vector!

plot(philly_crimes_sf["homic_rate"])
```

Based on the plot above, it would seem that we have a lot of "empty"
geographic units or unevenly distributed

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

ggplot(philly_crimes_sf) +
  geom_histogram(mapping = aes(x = homic_rate))
```

Let's break the plot up into quantiles to better distinguish the
census tracts with low values.

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

plot(philly_crimes_sf["homic_rate"], 
     main = "Philadelphia homicide density per square km", 
     breaks = "quantile")
```



### Mapping with `ggplot()`

Package `ggplot` is a widely used and powerful plotting library for R as we
have utilized over the course of the semester. It is not specifically
geared towards mapping, but one can generate great maps.
  
```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

ggplot(philly_crimes_sf) + 
  geom_sf(aes(fill=homic_rate))
```


Homicide rate is a continuous variable and is plotted by ggplot as
such. If we wanted to plot our map as a ‘true’ choropleth map we need
to convert our continuous variable into a categorical one, according
to whichever brackets we want to use.


```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

breaks_qt <- classInt::classIntervals(
                           c(min(philly_crimes_sf$homic_rate) - .00001,
                             philly_crimes_sf$homic_rate),
                           n = 7, style = "quantile")

philly_crimes_sf <- mutate(philly_crimes_sf,
                           homic_rate_cat = cut(homic_rate, breaks_qt$brks)) 

ggplot(philly_crimes_sf) + 
    geom_sf(aes(fill=homic_rate_cat)) +
    scale_fill_brewer(palette = "OrRd") 
```


### Mapping with `tmap()`

Package `tmap` is based on the idea of a 'grammar of graphics' similar
to `ggplot`  This involves a separation between the input data and the
aesthetics (how data are visualized): each input dataset can be
‘mapped’ in a range of different ways including location on the map
(defined by data’s geometry), color, and other visual variables. The
package is specifically designed to make creation of thematic maps
more convenient with `ggplot` syntax.


+ `tm_shape()` defines the data, raster, and vector objects.
	
+ `tm_polygons()` sets the attribute variable to map, the break style,
  and a title.

+ `tm_fill()` & `tm_borders()` control the layers.
  

  
```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

library(tmap)

m <- tm_shape(philly_crimes_sf) +
    tm_polygons(
        "homic_rate",
        fill.scale = tm_scale_intervals(style = "quantile", n = 4),
        fill.legend = tm_legend("Philadelphia \nhomicide density \nper sqKm")
    )

m
```

Package `tmap` has a nice feature that allows us to give basic
interactivity to the map. We can switch from `plot` mode into `view`
mode and call the plot.
  

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

tmap_mode("view")

m
```

**Layers** can be controlled by `tm_fill()` & `tm_borders()`.


```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%
#
#install.packages("spData")
library(spData)
library(tmap)

# Add fill layer to nz shape
tm_shape(nz) +
  tm_fill() 

# Add border layer to nz shape
tm_shape(nz) +
  tm_borders() 

# Add fill and border layers to nz shape
tm_shape(nz) +
  tm_fill() +
  tm_borders() 
```

 A useful feature of `tmap` is its ability to store objects representing maps

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

map_nz = tm_shape(nz) + tm_polygons()

class(map_nz)
```

-   This allows you to plot your maps later and/or add additional layers

```{r}
#| eval: TRUE

map_nz1 <- map_nz + 
    tm_polygons("Population",  fill.scale = tm_scale_intervals(),
                palette = "viridis", 
                title = "Population (by region)") +
    tm_layout(frame = FALSE)

map_nz1
```


There are no limits to the number of layers or shapes that can be
added to `tmap` objects.  Additionally, `tmap` allows multiple map
objects to be arranged in a single plot with `tmap_arrange()`


```{r}
#| eval: FALSE

map_nz2 <- tm_shape(nz) +
  tm_polygons("Median_income", style = "pretty", palette = "brewer.blues",
              title = "Median income")

# combined
tmap_arrange(map_nz1, map_nz2) #, map_nz3)
```


#### Animation with Package `gifski`


Consider the United Nations urban populaton data including projections.
Package `tmap`  makes it easy to create maps with `year` as facet.

```
urb_1970_2030 <- urban_agglomerations |>
  filter(year == 1970| year == 1990 | year == 2010 | year == 2030) 


tm_shape(world) +
  tm_polygons() +
  tm_shape(urb_1970_2030) +
  tm_symbols(col = "black", border.col = "white", size = "population_millions") +
  tm_facets(by = "year", nrow = 2, free.coords = FALSE)


urb_anim = tm_shape(world) + tm_polygons() + 
  tm_shape(urban_agglomerations) + tm_dots(size = "population_millions") +
  tm_facets(along = "year", free.coords = FALSE)

```


Package `gifski` takes the `urb_anim` object and create a GIF image,
in which each year is a frame.
```
library(gifski)

tmap_animation(urb_anim, filename = "urb_anim.gif", delay = 25)
```

<!-- For the Quarto output, we can call `tmap_leaflet()`. -->
<!-- ``` -->
<!-- #| echo: TRUE -->
<!-- #| eval: TRUE -->
<!-- #| out-width: 100% -->
<!-- #| out-height: 100% -->

<!-- library("htmlwidget") -->
<!-- tmap_leaflet(m) #  forces inline interactive leaflet map -->
<!-- ``` -->


### Mapping with `leaflet()`

Package `leaflet` provides bindings to the `Leaflet` JavaScript
library, "the leading open-source JavaScript library for
mobile-friendly interactive maps."
We have already seen a simple use of leaflet in the `tmap` example.


Let’s build up the map step by step

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%


library(leaflet) 

# reproject
philly_WGS84 <- st_transform(philly_crimes_sf, 4326)

leaflet(philly_WGS84) %>%
  addPolygons()
```

To map the homicide density we use `addPolygons()`

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%


pal_fun <- colorQuantile("YlOrRd", NULL, n = 5)

p_popup <- paste0("<strong>Homicide Density: </strong>", philly_WGS84$homic_rate)

m <- leaflet(philly_WGS84) %>%
    addPolygons(
        stroke = FALSE, # remove polygon borders
        fillColor = ~pal_fun(homic_rate), # set fill color with function from above and value
        fillOpacity = 0.8, smoothFactor = 0.5, # make it nicer
        popup = p_popup)  # add popup

m
```

We can add a basemap, which defaults to OSM, with `addTiles()`

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

m <- addTiles(m)
m
```

Lastly, we add a legend with `addLegend()`

```{r}
#| eval: TRUE
#| echo: TRUE
#| out-width: 100%
#| out-height: 100%

m <-  addLegend(m,
                "bottomright",  # location
                pal=pal_fun,    # palette function
                values=~homic_rate,  # value to be passed to palette function
                title = 'Philadelphia homicide density per sqkm') # legend title

m
```


<!-- ## For Next Class -->

<!-- -   Review what you learned today -->

<!-- -   Do new set of readings: -->

<!--     -   We are going to continue or discuss of relational data -->
<!--     -   [USDR Chapter 3.5-3.6]{style="color:#000E2F"} -->
<!--     -   [GCR Chapter 8.3-8.6]{style="color:#000E2F"} -->
<!--     -   [MSR Chapter 1-4]{style="color:#000E2F"} -->
<!--     -   [MSR Chapter 12]{style="color:#000E2F"} -->
<!--         -   Follow along the exercises with your own computer -->

<!-- -   Bring your laptops to class -->
